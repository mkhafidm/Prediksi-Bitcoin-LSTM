# -*- coding: utf-8 -*-
"""Prediksi Harga Bitcoin Menggunakan Algoritma LSTM.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1X03ZGSvhJDd4VY5AbqdB8tfPmy3Qa1se

# Prediksi Harga Bitcoin Menggunakan Algoritma LSTM

## Import Library
"""

import yfinance as yf
import pandas as pd
import numpy as np

# scaler
from sklearn.preprocessing import MinMaxScaler
from sklearn.metrics import mean_squared_error, mean_absolute_error, mean_absolute_percentage_error

# modelling
import tensorflow as tf
from keras.models import Sequential
from keras.layers import LSTM, Dense, Dropout

# visualization

import seaborn as sns
import matplotlib.pyplot as plt
import matplotlib.dates as mdates

"""## Data Fecther"""

def get_bitcoin_data(start_date, end_date):
  data = yf.Ticker('BTC-USD')
  df = data.history(start=start_date, end=end_date)
  return df

start_date = input('Masukkan tanggal mulai (format YYY-MM-DD):')
end_date = input('Masukkan tanggal akhir (format YYYY-MM-DD):')

data_bitcoin = get_bitcoin_data(start_date, end_date)
data_bitcoin.to_csv(f'bitcoin_{start_date}_to_{end_date}.csv')
print(data_bitcoin.head())

df = pd.read_csv(f'bitcoin_{start_date}_to_{end_date}.csv')
df.head()

"""## Data Cleaning"""

# mengubah kolom date menjadi tipe datetime
df['Date'] = pd.to_datetime(df['Date'])

# menghilangkan waktu dari kolom date
df['Date'] = df['Date'].dt.date

# set date as index
df = df.set_index('Date')

# menghapus kolom yang tidak diperlukan
df = df.drop(['Dividends', 'Stock Splits'], axis=1)
df

df.shape

df.info()

df.isnull().sum()

"""## EDA

### High and Low
"""

sns.set_style('whitegrid')
plt.figure(figsize=(15, 7))
plt.gca().xaxis.set_major_formatter(mdates.DateFormatter('%Y-%m-%d'))
plt.gca().xaxis.set_major_locator(mdates.MonthLocator(interval=6))
x_dates = df.index.values

plt.plot(x_dates, df['High'], label='High')
plt.plot(x_dates, df['Low'], label='Low')
plt.xlabel('Date')
plt.ylabel('Price (USD)')
plt.title(f'Bitcoin Price (High and Low)\n{start_date} to {end_date}', fontsize = 20)
plt.legend()
plt.gcf().autofmt_xdate()
plt.show()

"""### Open and Close"""

plt.figure(figsize=(15, 7))
plt.gca().xaxis.set_major_formatter(mdates.DateFormatter('%Y-%m-%d'))
plt.gca().xaxis.set_major_locator(mdates.MonthLocator(interval=6))

plt.plot(x_dates, df['Open'], label='Open')
plt.plot(x_dates, df['Close'], label='Close')
plt.xlabel('Date')
plt.ylabel('Price (USD)')
plt.title(f'Bitcoin Price (Open and Close)\n{start_date} to {end_date}', fontsize = 20)
plt.legend()
plt.gcf().autofmt_xdate()
plt.show()

"""### Close"""

plt.figure(figsize=(15, 7))
plt.gca().xaxis.set_major_formatter(mdates.DateFormatter('%Y-%m-%d'))
plt.gca().xaxis.set_major_locator(mdates.MonthLocator(interval=6))

plt.plot(x_dates, df['Close'], label='Close')
plt.xlabel('Date')
plt.ylabel('Price (USD)')
plt.title(f'Bitcoin Price (Close)\n{start_date} to {end_date}', fontsize = 20)
plt.legend()
plt.gcf().autofmt_xdate()
plt.show()

"""## Data Preprocessing

### Normalization
"""

# MinMaxScaler
scaler = MinMaxScaler(feature_range=(0,1))
df['Close_ms'] = scaler.fit_transform(df[['Close']])

"""### Split Data"""

def split_data(df, train_size):
  size = int(len(df) * train_size)
  train_data, test_data = df.iloc[0:size], df.iloc[size:len(df)]
  return train_data, test_data

train_data, test_data = split_data(df['Close_ms'], 0.8)

"""### Visualization"""

plt.figure(figsize=(15, 7))
plt.plot(train_data)
plt.plot(test_data)
plt.legend(labels=['Training', 'Testing'])
plt.title('Bitcoin Price\n80% Training and 20% Testing')

"""## Create Datset for LSTM Model"""

# Pembuatan dataset untuk LSTM
def create_dataset(df, timesteps=7):
  dataX, dataY = [], []
  for i in range(len(df)- timesteps):
    a = df[i:(i+timesteps),0]
    dataX.append(a)
    dataY.append(df[i+timesteps,0]) # menggunakan variabel Close sebagai target
  return np.array(dataX), np.array(dataY)

X_train, y_train = create_dataset(train_data.values.reshape(len(train_data),1))
X_test, y_test = create_dataset(test_data.values.reshape(len(test_data),1))
X_train.shape,  y_train.shape, X_test.shape, y_test.shape

# Reshape Data (samples, timesteps, features)
X_train = X_train.reshape((X_train.shape[0], X_train.shape[1], 1))
X_test = X_test.reshape((X_test.shape[0],  X_test.shape[1], 1))
X_train.shape, X_test.shape

"""## Build LSTM Model"""

# callbacks
class Callback(tf.keras.callbacks.Callback):
  def on_epoch_end(self, epoch, logs={}):
    if logs.get('val_mae') is not None and logs.get('val_mae') < 0.01:
      self.model.stop_training = True

# Model architecture
model = Sequential()
model.add(LSTM(128,return_sequences=True, input_shape=(X_train.shape[1], 1)))
model.add(Dropout(0.2))
model.add(LSTM(64))
model.add(Dropout(0.2))
model.add(Dense(32, activation='relu'))
model.add(Dense(1))

model.summary()

# Compile model
optimizer = tf.keras.optimizers.Adam(learning_rate=0.0001)
model.compile(optimizer=optimizer,
              metrics=['mae'],
              loss= tf.keras.losses.Huber())

"""
## Training Model"""

# Train model
history = model.fit(X_train,
                    y_train,
                    epochs=200,
                    batch_size=32,
                    validation_data=(X_test, y_test),
                    shuffle=False,
                    callbacks=[Callback()])

"""### Visualization Training Result"""

sns.set_style('darkgrid')
fig, (ax1, ax2) = plt.subplots(1, 2, figsize=(15, 5))

# loss = huber
ax1.plot(history.history['loss'])
ax1.plot(history.history['val_loss'])
ax1.legend(['Loss', 'Val Loss'])
ax1.set_xlabel('Epoch', fontsize=12)
ax1.set_ylabel('Loss', fontsize=12)
ax1.set_title('Loss', fontsize=20)

# metrics = mae
ax2.plot(history.history['mae'])
ax2.plot(history.history['val_mae'])
ax2.legend(['mae', 'Val mae'])
ax2.set_xlabel('Epoch', fontsize=12)
ax2.set_ylabel('Mean Absolute Error', fontsize=12)
ax2.set_title('Mean Absolute Error', fontsize=20)

plt.show()

"""## Evaluation"""

loss, mae = model.evaluate(X_test, y_test)
print('Loss:', loss)
print('MAE:', mae)

"""## Prediction"""

# Prediksi Data Test
pred = model.predict(X_test)
y_pred = np.array(pred).reshape(-1)

mae = mean_absolute_error(y_test, y_pred)
rmse = mean_squared_error(y_test, y_pred, squared=False)
mape = mean_absolute_percentage_error(y_test, y_pred)
print('MAE:', mae)
print('RMSE:', rmse)
print('MAPE:', mape)

plt.figure(figsize=(15, 7))
plt.plot(test_data.index[7:], y_test, color='red', label='Actual')
plt.plot(test_data.index[7:], y_pred, color='blue', label='Predicted')
plt.text(test_data.index[50], 0.45, f"MAE: {mean_absolute_error(y_test, y_pred)}", style='italic', bbox={'facecolor':'orange', 'alpha':0.5, 'pad':10})

plt.xlabel('Date')
plt.ylabel('Bitcoin Price')
plt.title('Bitcoin Price Prediction\nLSTM', fontsize = 20)
plt.gca().xaxis.set_major_locator(mdates.AutoDateLocator())
plt.gca().xaxis.set_major_formatter(mdates.DateFormatter('%Y-%m-%d'))
plt.gcf().autofmt_xdate()
plt.legend()
plt.show()

"""## Visualization Prediction Results"""

# Inverse transform the predicted values
y_pred_original = scaler.inverse_transform(np.array(y_pred).reshape(-1, 1))

# Plot the actual and predicted prices
plt.figure(figsize=(15, 7))
plt.plot(df.index, df['Close'], color='blue', label='Actual')
plt.plot(df.index[-len(y_pred_original):], y_pred_original, color='red', label='Predicted')
plt.xlabel('Date')
plt.ylabel('Bitcoin Price (USD)')
plt.title(f'Bitcoin Price Prediction\n{start_date} to {end_date}\nLSTM', fontsize=20)
plt.gca().xaxis.set_major_formatter(mdates.DateFormatter('%Y-%m-%d'))
plt.gca().xaxis.set_major_locator(mdates.MonthLocator(interval=6))
# Rotate x-axis labels
plt.xticks(rotation=30)

plt.legend()
plt.show()

"""## Save Prediction Results to CSV"""

df_pred = pd.DataFrame({
    'Date': test_data.index[7:],
    'Actual': scaler.inverse_transform(y_test.reshape(-1, 1)).reshape(-1),
    'Predicted': y_pred_original.reshape(-1)
})

date = f'{start_date} to {end_date}'
df_pred.to_csv(f'bitcoin_prediction_{date}.csv')
print(f'File bitcoin_prediction_{date}.csv telah berhasil disimpan')

